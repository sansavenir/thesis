% !TEX root = ../thesis.tex

% set counter to n-1:
\setcounter{chapter}{0}

\chapter{Introduction}
\mbox{}\\
\mbox{}\\
\mbox{}\\
The number of domains controlled by computers has grown exponentially in the recent years. As the complexity of the structures surrounding us grows, the need for their automatisation grows accordingly. And so, more and more of the systems around us, become controlled by computers. From simple things such as automatic doors to vastly more complex and important systems such as self-driving cars, medical software or nuclear weapons software. In some of these applications a program bug could only be a slight nuisance, but in others its existence could have major implications. A few infamous examples of these exist where buffer overflows, rounding errors or division by zeros have caused space craft crashes or lethal radiation overdoses. As such, the importance of some of these devices demands their invulnerability and its verifiability. Unfortunately, as the complexity of these programs increases their verification can no longer be simply done by hand and the need for complete and formal verification methods becomes critical.\\
Static analysis is a sub-branch of computer science. Its task is to analyse a program without its execution. It does this in the goal of discovering weaknesses inside of the code that could lead to vulnerabilities. As such, it should help with debugging and provide a better notion of safety about the code. Static analysis has seen a growing commercial use in the recent years mostly in safety-critical domains. Recent advances in this field use clever mathematical properties in order to increase the capabilities of such methods. Other techniques, leverage the domain of artificial intelligence to increase the fields capacities. For, until ai is capable of writing invulnerable software for us, we can at least use it to verify ours.
\section{Problem Statement}
The main focus of static analysis is observing the effects that program expressions and statements have on the variables inside of the program. In order for these methods to work, a numerical abstract domain is needed that can capture the relationships between the variables. An important attribute of a domain is its expressivity, that is to say, how complex are the constraints between variables that the domain can represent. The more expressive a domain is the more complicated relationships it can represent. The most expressive domain is the polyhedra domain that represents the constraints with different polyhedra. However, its expressivity comes at a cost. It is notoriously time and space complex, having worst case exponential complexities in both. Other domains also exits that do not suffer from these problems. Unfortunately, to achieve this, they loose their expressivity. Various methods exist that attempt to increase the performance of the polyhedra domain. Some of these methods exchange some precision loss to increase the performance. However, finding the right balance between these two is not an easy task.

\section{Goals}
The goal of this thesis is to use some of the recent developments in new areas of reinforcement learning. To adapt and optimise these novel methods in order to to use them in polyhedra analysis. The goal is then to optimise these methods with some problem specific knowledge from polyhedra analysis, in order to render the analysis more efficient and learn an action selection policy that achieves the correct balance between precision and performance, hopefully outperforming preexisting methods.

\section{Related work}
The concept of using reinforcement learning to decide between different operators with various levels of abstraction has been explored in \cite{singh2018fast}. This work used Q-learning for the Q-function approximation. Other works also explore the idea of leveraging precision loss for performance gains \cite{oh2015learning,oh2014selective,liang2011learning}. These works fall into the domain of parametric program analysis, which attempts to tune the precision and cost of the given analysis according to the program being analysed. The main difference between these works and ours, is that they do not adaptively tune the analysis while it is being conducted. The work \cite{chen2008sound} uses a floating point representation of the polyhedra to increase performance with the loss of some precision as well.\\
Other works increase the performance of static analysers without the loss of precision \\ \cite{singh2015making,singh2017fast}. However these analyses remain slower than ours as with our method we were able to outperform \cite{singh2018fast}, which in turn already outperformed \cite{singh2015making,singh2017fast}.


\section{Structure of this Document}

\paragraph{Chapter 2}briefly introduces reinforcement learning, explaining the important concepts and its main goals. It will also describe some of the recent advances inside of the field and the achievements of these methods.

\paragraph{Chapter 3}addresses Polyhedra analysis. It will explain its usefulness inside of static analysers and how it works. It will also introduce some of the modifications made to the domain, in order to reduce some of its shortcomings.

\paragraph{Chapter 4}addresses the work done throughout this thesis. It will first address how the two previous chapters were combined and the basic algorithm was designed. It will also show the different methods tested to further optimise the results.

\paragraph{Chapter 5}discusses the different experiments that were run whilst finding the optimal combination of parts for the algorithm. It will also present the results of the execution of the finalised versions of our algorithms on different benchmarks.

\paragraph{Chapter 6}will be a final discussion on what was achieved during this thesis and the results we were able to obtain.









